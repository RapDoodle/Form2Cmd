<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading...</title>
</head>

<body>
  <div class="main-block">
    <form id="main-form" action="/">
      <div class="main-form-title">
        <h1 id="gui-title"></h1>
      </div>
      <div class="main-form-block">
      </div>
      <button id="submitBtn" type="submit">Submit</button>
      <input id="cmdField" type="hidden" style="width:100%;padding:10px 0;margin: 5px auto;" readonly rows="5"></input>
    </form>
  </div>

  <script src="gui.manifest.js"></script>

  <script>
    // Functions

    /**
     * Process values. It does the following things:
     *  1. Escape backslashes (\)
     *  2. Escape any double quotes.
     *  3. If the value contains spaces, insert double quotes.
     * 
     * @param {string} Argument value
     * 
     * @return {string} The parsed value
     */
    const parseValue = (value) => {
      value = value.replaceAll('\\', '\\\\')
      value = value.replaceAll('"', '\\\"')
      value = /\s/.test(value) ? "\"" + value + "\"" : value
      return value
    }

    /**
     * Convert form input into commands in the order of 
     * command priorities. Display the converted command
     * on textarea.
     * 
     * @return {string} The parsed command
     */
    const toCommand = () => {
      let command = blueprint.command.prefix

      // Process command conversion in command priority's
      // ascending order
      priorityArr.forEach((bpArr, pri) => {
        if (bpArr) {
          bpArr.forEach((bp) => {
            if (bp.type === 'radio') {
              // Iterate through all radio buttons
              bp.elements.forEach((inp, idx) => {
                if (inp.checked) {
                  // If ignoreOnDisabled is true and the element is disabled, ignore the element
                  if (bp.command && bp.command.ignoreOnDisabled && inp.disabled) {
                    return
                  }

                  if (bp.command.type.toLowerCase() === 'str') {
                    command += " " + bp.command.arg + blueprint.command.separator + parseValue(inp.value)
                  } else if (bp.command.type.toLowerCase() === 'flag') {
                    command += " " + bp.command.args[idx]
                  }
                }
              })
            } else {
              // If ignoreOnDisabled is true and the element is disabled, ignore the element
              if (bp.command && bp.command.ignoreOnDisabled && bp.element.disabled) {
                return
              }
              
              if (bp.command.type.toLowerCase() === 'str') {
                // Input with value attributes
                if (bp.element.value.length > 0) {
                  command += " " + bp.command.arg + blueprint.command.separator + parseValue(bp.element.value)
                }
              } else if (bp.command.type.toLowerCase() === 'flag') {
                if (bp.element.checked) {
                  // Checkboxes
                  command += " " + bp.command.arg
                }
              }
            }
          })
        }
      })

      // Display on textarea
      const cmdField = document.querySelector('#cmdField')
      cmdField.setAttribute('type', 'textarea')
      cmdField.value = command

      return command
    }

    /**
     * Register blueprint with the priority array. Radix sort is
     * implemented to sort arguments with different priorities.
     * 
     * @param {object}: Form item's blueprint
     */
    const registerBlueprint = (currItemBp) => {
      // Use a default order of 255
      if (!currItemBp.command.order) {
        currItemBp.command.order = 255
      }

      // Create an array if the given position is null
      if (!priorityArr[currItemBp.command.order]) {
        priorityArr[currItemBp.command.order] = new Array()
      }

      // Push the current blueprint to the array in the specified order
      priorityArr[currItemBp.command.order].push(currItemBp)
    }

    /**
     * Set input attributes.
     * 
     * @param {object} The input element.
     * @param {object} The attributes (blueprint).
     */
    const setInputAttributes = (input, attributes) => {
      // Placeholder attribute
      if (attributes.placeholder) {
        input.setAttribute('placeholder', attributes.placeholder)
      }

      // Required attribute
      if (attributes.required) {
        input.setAttribute('required', '')
      }

      // Checked attribute. Only for radio
      if (attributes.checked) {
        input.setAttribute('checked', '')
      }

      // Disabled attribute
      if (attributes.disabled) {
        input.setAttribute('disabled', '')
      }
    }

    /**
     * Generate form elements and add it to DOM recursively.
     * 
     * @param {object} The container that holds all the form items of the
     *                 current level.
     * @param {object} The blueprint that specifies the current level's 
     *                 form items.
     */
    const createFormElements = (base, formBlueprint) => {
      for (let i = 0; i < formBlueprint.length; i++) {
        const currItemBp = formBlueprint[i]
        if (currItemBp.type.toLowerCase().startsWith("fieldset")) {
          // Fieldset block, recursively generate form items
          const fieldset = document.createElement('fieldset')
          base.appendChild(fieldset)

          // Create legends
          const legend = document.createElement('legend')
          const h3 = document.createElement('h3')
          h3.innerText = (currItemBp && currItemBp.title) ? currItemBp.title : ""
          legend.appendChild(h3)
          fieldset.appendChild(legend)

          // Form item container
          const fieldsetBlock = document.createElement('div')
          fieldsetBlock.classList = [currItemBp.type + '-block']
          fieldset.appendChild(fieldsetBlock)

          // Recursively generate form items
          createFormElements(fieldsetBlock, currItemBp.form)

        } else if (currItemBp.type === 'checkbox' || currItemBp.type === 'checbox-left') {
          // Default checkboxes: checkbox positioned left to the label
          const div = document.createElement('div')
          div.classList = ['checkbox']
          const input = document.createElement('input')
          input.setAttribute('type', 'checkbox')
          const span = document.createElement('span')
          span.innerText = currItemBp.label
          div.appendChild(input)
          div.appendChild(span)
          currItemBp.element = input
          base.appendChild(div)

          // Set input's attributes
          setInputAttributes(input, currItemBp)

          // Register elements with priority array
          registerBlueprint(currItemBp)

        } else {
          // Form items with input positioned right to the label
          const div = document.createElement('div')

          // Create labels
          const label = document.createElement('label')
          label.innerText = currItemBp.label ? currItemBp.label : ""
          div.appendChild(label)

          if (currItemBp.type === 'radio') {
            // Form items that need multiple input elements
            // A group of radio buttons
            const radioButtonsDiv = document.createElement('div')
            radioButtonsDiv.classList = ['radioButtons']
            const inputs = new Array()

            const generateRadios = (value, text) => {
              // Create the radio button
              const currInput = document.createElement('input')
              currInput.setAttribute('type', 'radio')
              currInput.setAttribute('value', value)
              currInput.setAttribute('name', label.innerText)

              // Set input's attributes
              setInputAttributes(currInput, currItemBp)

              // Handle default values
              if (currItemBp.default === value) {
                currInput.setAttribute('checked', '')
              }

              // Create the label
              const currLabel = document.createElement('label')
              currLabel.classList = ['radio']
              currLabel.setAttribute('for', value)
              currLabel.innerText = text

              inputs.push(currInput)
              radioButtonsDiv.appendChild(currInput)
              radioButtonsDiv.appendChild(currLabel)
            }

            currItemBp.options.forEach((obj) => {
              if (typeof(obj) === 'string') {
                // An array, use the same text for value and text description
                generateRadios(obj, obj)
              } else {
                // An object with value->text pair
                generateRadios(obj.value, obj.text)
              }
            })

            div.appendChild(radioButtonsDiv)
            currItemBp.elements = inputs

          } else {
            // Form items that only need one input element
            let input = null
            if (currItemBp.type === 'select') {
              // Special routine for select
              input = document.createElement('select')
              if (!currItemBp.default) {
                const emptyOpt = document.createElement('option')
                input.appendChild(emptyOpt)
              }

              const generateOptions = (value, name) => {
                const currOpt = document.createElement('option')
                currOpt.setAttribute('value', value)
                currOpt.innerText = name

                // Handle selected option
                if (currItemBp.default && value == currItemBp.default) {
                  currOpt.setAttribute('selected', 'selected')
                }

                input.appendChild(currOpt)
              }

              currItemBp.options.forEach((obj) => {
                if (typeof(obj) === 'string') {
                  // An array, use the same text for value and text description
                  generateOptions(obj, obj)
                } else {
                  // An object with value->text pair
                  generateOptions(obj.value, obj.text)
                }
              })

              input.setAttribute('type', currItemBp.type)

            } else if (currItemBp.type === 'checkbox-right') {
              // Special routine for checkboxes displayed to the right of label
              input = document.createElement('input')
              input.setAttribute('type', 'checkbox')

              // Set input's attributes
              setInputAttributes(input, currItemBp)
            } else {
              // Other input types
              input = document.createElement('input')
              input.setAttribute('type', currItemBp.type)
            }

            // Set input's attributes
            setInputAttributes(input, currItemBp)

            // Process the help message (display upon hover)
            if (currItemBp.help) {
              label.setAttribute('title', currItemBp.help)
            }

            // Process default values
            if (currItemBp.default) {
              input.setAttribute('value', currItemBp.default)
            }

            div.appendChild(input)
            currItemBp.element = input
          }

          base.appendChild(div)

          // Register elements with priority array
          registerBlueprint(currItemBp)
        }
      }
    }

  </script>

  <script>
    // Setup script
    // Priority array. Priority ranges from 0 to 255
    const priorityArr = new Array()
    priorityArr.length = 256

    // Configure title
    document.title = (blueprint && blueprint.meta && blueprint.meta.title) ? blueprint.meta.title : "Untitled GUI"
    document.querySelector('#gui-title').innerText = document.title

    // Prevent submit button's default behavior. Define onclick actions.
    document.querySelector('#submitBtn').addEventListener("click", (event) => {
      if (!document.querySelector('#main-form').checkValidity()) {
        document.querySelector('#main-form').reportValidity()
      } else {
        event.preventDefault()
        toCommand()
      }
    })

    // Output command field: Select all text on click
    document.querySelector('#cmdField').addEventListener('click', (event) => {
      event.target.focus()
      event.target.select()
    })

    // Generate form entries recursively
    const formBase = document.querySelector('#main-form>.main-form-block')
    const formBlueprintBase = blueprint.form
    createFormElements(formBase, formBlueprintBase)
  </script>

  <style>
    html,
    body {
      min-height: 100%;
    }

    body,
    div,
    form,
    input,
    select,
    p {
      padding: 0;
      margin: 0;
      outline: none;
      font-family: Roboto, Arial, sans-serif;
      font-size: 14px;
      color: #666;
    }

    h1 {
      margin: 0;
      font-weight: 400;
      color: #007bff;
    }

    h3 {
      margin: 12px 0;
      color: #007bff;
    }

    .main-form-title {
      padding: 0 0 0 10px;
    }

    .main-block {
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
    }

    #main-form {
      width: 100%;
      padding: 20px;
    }

    fieldset {
      border: none;
      border-top: 1px solid #007bff;
    }

    .fieldset-block {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .fieldset-block>div {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .fieldset-block>div,
    input,
    label {
      width: 100%;
    }

    label {
      padding: 0 5px;
      text-align: right;
      vertical-align: middle;
    }

    input {
      padding: 5px;
      vertical-align: middle;
    }

    .checkbox {
      margin-bottom: 10px;
    }

    select,
    .radioButtons {
      width: calc(100% + 26px);
      padding: 5px 0;
    }

    select {
      background: transparent;
    }

    input[type="radio"] {
      width: auto;
    }

    .radioButtons[type="radio"] {
      padding: 0 5px 0 0;
    }

    .birthdate select.day {
      width: 35px;
    }

    .birthdate select.mounth {
      width: calc(100% - 94px);
    }

    .birthdate input {
      width: 38px;
      vertical-align: unset;
    }

    input[type="checkbox"] {
      width: auto;
      margin: -2px 10px 0 0;
    }

    .checkbox a {
      color: #007bff;
    }

    .checkbox a:hover {
      color: #0069CF;
    }

    button {
      width: 100%;
      padding: 10px 0;
      margin: 10px auto;
      border-radius: 5px;
      border: none;
      background: #007bff;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    button:hover {
      background: #0069CF;
    }

    @media (min-width: 568px) {
      .fieldset-block>div {
        width: 50%;
      }

      label {
        width: 40%;
      }

      input {
        width: 60%;
      }

      select,
      .radioButtons {
        width: calc(60% + 16px);
      }
    }
  </style>
</body>

</html>