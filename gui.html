<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading...</title>
</head>

<body>
  <div class="main-block">
    <form id="main-form" action="/">
      <div class="main-form-title">
        <h1 id="gui-title"></h1>
      </div>
      <div class="main-form-block">
      </div>
      <button id="submitBtn" type="submit">Submit</button>
      <input id="cmdField" type="hidden" style="width:100%;padding:10px 0;margin: 5px auto;" readonly rows="5"></input>
    </form>
  </div>

  <script src="gui.manifest.js"></script>

  <script>
    // Functions

    /**
     * Process values. It does the following things:
     *  1. Escape backslashes (\)
     *  2. Escape any double quotes.
     *  3. If the value contains spaces, append double quotes.
     * 
     * @param {string} Argument value
     * 
     * @return {string} The parsed value
     */
    const parseValue = (value) => {
      value = value.replaceAll('\\', '\\\\')
      value = value.replaceAll('"', '\\\"')
      value = /\s/.test(value) ? "\"" + value + "\"" : value
      return value
    }

    /**
     * Convert form input into commands in the order of 
     * command priorities. Display the converted command
     * on textarea.
     * 
     * @return {string} The parsed command
     */
    const toCommand = () => {
      let command = blueprint.command.prefix

      // Process command conversion in command priority's
      // ascending order
      priorityArr.forEach((bpArr, pri) => {
        if (bpArr) {
          bpArr.forEach((bp) => {
            if (bp.type === 'radio') {
              // Iterate through all radio buttons
              bp.elements.forEach((i) => {
                if (i.checked) {
                  command += " " + bp.command.arg + blueprint.command.separator + parseValue(i.value)
                }
              })
            } else {
              if (bp.command.type.toLowerCase() === 'str') {
                // Input with value attributes
                if (bp.element.value.length > 0) {
                  command += " " + bp.command.arg + blueprint.command.separator + parseValue(bp.element.value)
                }
              } else if (bp.command.type.toLowerCase() === 'flag') {
                if (bp.element.checked) {
                  // Checkboxes
                  command += " " + bp.command.arg
                }
              }
            }
          })
        }
      })

      // Display on textarea
      const cmdField = document.querySelector('#cmdField')
      cmdField.setAttribute('type', 'textarea')
      cmdField.value = command
      
      return command
    }

    /**
     * Register blueprint with priority array
     * 
     * @param {object}: Form item's blueprint
     */
    const registerBlueprint = (currFormBp) => {
      // Use a default order of 255
      if (!currFormBp.command.order) {
        currFormBp.command.order = 255
      }

      // Create an array if the given position is null
      if (!priorityArr[currFormBp.command.order]) {
        priorityArr[currFormBp.command.order] = new Array()
      }

      // Push the current blueprint to the array in the specified order
      priorityArr[currFormBp.command.order].push(currFormBp)
    }

    /**
     * Generate form elements and add it to DOM recursively.
     * 
     * @param {object} The container that holds all the form items of the
     *                 current level.
     * @param {object} The blueprint that specifies the current level's 
     *                 form items.
     */
    const createFormElements = (base, formBlueprint) => {
      for (let i = 0; i < formBlueprint.length; i++) {
        const currFormBp = formBlueprint[i]
        if (currFormBp['type'].toLowerCase().startsWith("fieldset")) {
          // Fieldset block, recursively generate form items
          const fieldset = document.createElement('fieldset')
          base.appendChild(fieldset)

          // Create legends
          const legend = document.createElement('legend')
          const h3 = document.createElement('h3')
          h3.innerText = (currFormBp && currFormBp.title) ? currFormBp.title : ""
          legend.appendChild(h3)
          fieldset.appendChild(legend)

          // Form item container
          const fieldsetBlock = document.createElement('div')
          fieldsetBlock.classList = [currFormBp.type + '-block']
          fieldset.appendChild(fieldsetBlock)

          // Recursively generate form items
          createFormElements(fieldsetBlock, currFormBp.form)

        } else if (currFormBp.type === 'checkbox' || currFormBp.type === 'checbox-left') {
          // Default checkboxes: checkbox positioned left to the label
          const div = document.createElement('div')
          div.classList = ['checkbox']
          const input = document.createElement('input')
          input.setAttribute('type', 'checkbox')
          const span = document.createElement('span')
          span.innerText = currFormBp.label
          div.appendChild(input)
          div.appendChild(span)
          currFormBp.element = input
          base.appendChild(div)

          if (currFormBp.checked) {
            input.setAttribute('checked', '')
          }

          // Required
          if (currFormBp.required) {
            input.setAttribute('required', '')
          }

          // Register elements with priority array
          registerBlueprint(currFormBp)

        } else {
          // Form items with input positioned right to the label
          const div = document.createElement('div')

          // Create labels
          const label = document.createElement('label')
          label.innerText = currFormBp.label ? currFormBp.label : ""
          div.appendChild(label)

          if (currFormBp.type === 'radio') {
            // Form items that need multiple input elements
            // A group of radio buttons
            const radioButtonsDiv = document.createElement('div')
            radioButtonsDiv.classList = ['radioButtons']
            const inputs = new Array()

            const generateRadios = (value, text) => {
              // Create the radio button
              const currInput = document.createElement('input')
              currInput.setAttribute('type', 'radio')
              currInput.setAttribute('value', value)
              currInput.setAttribute('name', label.innerText)

              // Handle required attribute
              if (currFormBp.required) {
                currInput.setAttribute('required', '')
              }

              // Handle default values
              if (currFormBp.default === value) {
                currInput.setAttribute('checked', '')
              }

              // Create the label
              const currLabel = document.createElement('label')
              currLabel.classList = ['radio']
              currLabel.setAttribute('for', value)
              currLabel.innerText = text

              inputs.push(currInput)
              radioButtonsDiv.appendChild(currInput)
              radioButtonsDiv.appendChild(currLabel)
            }

            if (Array.isArray(currFormBp.options)) {
              // An array, use the same text for value and text description
              currFormBp.options.forEach((text) => {
                generateRadios(text, text)
              })
            } else {
              // A normal object with value->text pair
              Object.entries(currFormBp.options).forEach((obj) => {
                generateRadios(obj[0], obj[1])
              })
            }

            div.appendChild(radioButtonsDiv)
            currFormBp.elements = inputs

          } else {
            // Form items that only need one input element
            let input = null
            if (currFormBp.type === 'select') {
              // Special routine for select
              input = document.createElement('select')
              if (!currFormBp.default) {
                const emptyOpt = document.createElement('option')
                input.appendChild(emptyOpt)
              }

              const generateOptions = (value, name) => {
                const currOpt = document.createElement('option')
                currOpt.setAttribute('value', value)
                currOpt.innerText = name

                // Handle selected option
                if (currFormBp.default && value == currFormBp.default) {
                  currOpt.setAttribute('selected', 'selected')
                }

                input.appendChild(currOpt)
              }

              if (Array.isArray(currFormBp.options)) {
                // An array, use the same text for value and text description
                currFormBp.options.forEach((text) => {
                  generateOptions(text, text)
                })
              } else {
                // A normal object with value->text pair
                Object.entries(currFormBp.options).forEach((obj) => {
                  generateOptions(obj[0], obj[1])
                })
              }

              input.setAttribute('type', currFormBp.type)

            } else if (currFormBp.type === 'checkbox-right') {
              // Special routine for checkboxes displayed to the right of label
              input = document.createElement('input')
              input.setAttribute('type', 'checkbox')

              if (currFormBp.checked) {
                input.setAttribute('checked', '')
              }
            } else {
              // Other input types
              input = document.createElement('input')
              input.setAttribute('type', currFormBp.type)
            }

            // Process placeholder
            if (currFormBp.placeholder) {
              input.setAttribute('placeholder', currFormBp.placeholder)
            }

            // Process the required attribute
            if (currFormBp.required) {
              input.setAttribute('required', '')
            }

            // Process the help message (display upon hover)
            if (currFormBp.help) {
              label.setAttribute('title', currFormBp.help)
            }

            // Process default values
            if (currFormBp.default) {
              input.setAttribute('value', currFormBp.default)
            }

            div.appendChild(input)
            currFormBp.element = input
          }

          base.appendChild(div)
          
          // Register elements with priority array
          registerBlueprint(currFormBp)
        }
      }
    }

  </script>

  <script>
    // Setup script
    // Priority array. Priority ranges from 0 to 255
    const priorityArr = new Array()
    priorityArr.length = 256

    // Configure title
    document.title = (blueprint && blueprint.meta && blueprint.meta.title) ? blueprint.meta.title : "Untitled GUI"
    document.querySelector('#gui-title').innerText = document.title

    // Prevent submit button's default behavior
    document.querySelector('#submitBtn').addEventListener("click", (event) => {
      if (!document.querySelector('#main-form').checkValidity()) {
        document.querySelector('#main-form').reportValidity();
      } else {
        event.preventDefault()
        toCommand()
      }
    })

    // Output command field: Select all text on click
    document.querySelector('#cmdField').addEventListener('click', (event) => {
      event.target.focus()
      event.target.select()
    })

    // Generate form entries recursively
    const formBase = document.querySelector('#main-form>.main-form-block')
    const formBlueprintBase = blueprint.form
    createFormElements(formBase, formBlueprintBase)
  </script>

  <style>
    html, body { min-height: 100%; }

    body, div, form, input, select, p {
      padding: 0;
      margin: 0;
      outline: none;
      font-family: Roboto, Arial, sans-serif;
      font-size: 14px;
      color: #666;
    }

    h1 {
      margin: 0;
      font-weight: 400;
      color: #007bff;
    }

    h3 {
      margin: 12px 0;
      color: #007bff;
    }

    .main-form-title { padding: 0 0 0 10px; }

    .main-block {
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
    }

    #main-form {
      width: 100%;
      padding: 20px;
    }

    fieldset {
      border: none;
      border-top: 1px solid #007bff;
    }

    .fieldset-block {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .fieldset-block>div {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .fieldset-block>div, input, label { width: 100%; }

    label {
      padding: 0 5px;
      text-align: right;
      vertical-align: middle;
    }

    input {
      padding: 5px;
      vertical-align: middle;
    }

    .checkbox { margin-bottom: 10px; }

    select, .radioButtons {
      width: calc(100% + 26px);
      padding: 5px 0;
    }

    select { background: transparent; }

    input[type="radio"] { width: auto; }

    .radioButtons[type="radio"] { padding: 0 5px 0 0; }

    .birthdate select.day { width: 35px; }

    .birthdate select.mounth { width: calc(100% - 94px); }

    .birthdate input {
      width: 38px;
      vertical-align: unset;
    }

    input[type="checkbox"] {
      width: auto;
      margin: -2px 10px 0 0;
    }

    .checkbox a { color: #007bff; }

    .checkbox a:hover { color: #0069CF; }

    button {
      width: 100%;
      padding: 10px 0;
      margin: 10px auto;
      border-radius: 5px;
      border: none;
      background: #007bff;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    button:hover { background: #0069CF; }

    @media (min-width: 568px) {
      .fieldset-block>div { width: 50%; }
      label { width: 40%; }
      input { width: 60%; }
      select, .radioButtons { width: calc(60% + 16px); }
    }
  </style>
</body>

</html>